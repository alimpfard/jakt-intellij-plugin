{
    parserClass="org.serenityos.jakt.parser.JaktParser"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Jakt"
    psiImplClassSuffix="Impl"
    psiPackage="org.intellij.sdk.language.psi"
    psiImplPackage="org.intellij.sdk.language.psi.impl"

    elementTypeHolderClass="org.serenityos.jakt.JaktTypes"
    elementTypeClass="org.serenityos.jakt.plugin.syntax.JaktElementType"
    tokenTypeClass="org.serenityos.jakt.plugin.syntax.JaktToken"

    parserUtilClass="org.serenityos.jakt.plugin.syntax.JaktParserUtil"

    tokens=[
        EXTERN_KEYWORD='extern'

        NAMESPACE_KEYWORD='namespace'
        CLASS_KEYWORD='class'
        STRUCT_KEYWORD='struct'
        ENUM_KEYWORD='enum'
        FUNCTION_KEYWORD='function'
        PUBLIC_KEYWORD='public'
        PRIVATE_KEYWORD='private'
        IMPORT_KEYWORD='import'

        LET_KEYWORD='let'
        MATCH_KEYWORD='match'
        IF_KEYWORD='if'
        ELSE_KEYWORD='else'

        WHILE_KEYWORD='while'
        LOOP_KEYWORD='loop'
        FOR_KEYWORD='for'
        IN_KEYWORD='in'
        UNSAFE_KEYWORD='unsafe'
        CPP_KEYWORD='cpp'

        RETURN_KEYWORD='return'
        THROW_KEYWORD='throw'
        DEFER_KEYWORD='defer'

        TRUE_KEYWORD='true'
        FALSE_KEYWORD='false'

        BOXED_KEYWORD='boxed'
        MUT_KEYWORD='mut'
        ANON_KEYWORD='anon'
        THIS_KEYWORD='this'
        RAW_KEYWORD='raw'
        WEAK_KEYWORD='weak'
        THROWS_KEYWORD='throws'

        PAREN_OPEN='('
        PAREN_CLOSE=')'
        CURLY_OPEN='{'
        CURLY_CLOSE='}'
        BRACKET_OPEN='['
        BRACKET_CLOSE=']'
        COLON=':'
        COLON_COLON='::'
        SEMICOLON=';'
        DOT='.'
        DOT_DOT='..'
        COMMA=','
        EQUALS='='
        DOUBLE_EQUALS='=='
        NOT_EQUALS='!='
        PLUS='+'
        MINUS='-'
        ASTERISK='*'
        SLASH='/'
        PLUS_PLUS='++'
        MINUS_MINUS='--'
        LEFT_SHIFT='<<'
        RIGHT_SHIFT='>>'
        ARITH_LEFT_SHIFT='<<<'
        ARITH_RIGHT_SHIFT='>>>'
        PERCENT='%'
        ARROW='->'
        FAT_ARROW='=>'
        QUESTION_MARK='?'
        DOUBLE_QUESTION_MARK='??'
        EXCLAMATION_POINT='!'
        LESS_THAN='<'
        LESS_THAN_EQUALS='<='
        GREATER_THAN='>'
        GREATER_THAN_EQUALS='>='
        AMPERSAND='&'
        PIPE='|'
        CARET='^'
        TILDE='~'
        AND='and'
        OR='or'
        NOT='not'
        AS='as'

        HEX_LITERAL="regexp:(0x|0X)[\dA-Fa-f](_?[\dA-Fa-f])*"
        BINARY_LITERAL="regexp:(0b|0B)[01](_?[01])*"
        DECIMAL_LITERAL="regexp:\d(_?\d)*"

        STRING_LITERAL="regexp:\"([^\"\\]|\\.)*\""
        BYTE_CHAR_LITERAL="regexp:b'([^'\\]|\\.)*'"
        CHAR_LITERAL="regexp:'([^'\\]|\\.)*'"
        IDENTIFIER="regexp:[A-Za-z_]\w*"

        COMMENT="regexp://[^\r\n]*"
        NEWLINE="regexp:[\r\n]"
    ]

    implements(".*")="org.serenityos.jakt.plugin.psi.JaktPsiElement"

    extends(".+BinaryExpression")=BinaryExpression
    extends(".+Expression")=Expression
    extends(".+Statement")=Statement

    name(".+Expression")=expression
    name(".+Statement")=statement

    generateTokenAccessors=true
}

/*************************************
 *               ROOT                *
 *************************************/

File ::= NL TopLevelDefinitionList? NL

private TopLevelDefinitionList ::= TopLevelDefinition (StatementSeparator TopLevelDefinition)*

TopLevelDefinition ::=
      FunctionDeclaration
    | StructDeclaration
    | EnumDeclaration
    | ExternDeclaration
    | NamespaceDeclaration
    | ImportStatement {
    implements="org.serenityos.jakt.plugin.psi.declaration.JaktNameIdentifierOwner"
    // For some reason this gets a getExternKeyword() function which conflicts
    // with ExternStructDeclaration
    generateTokenAccessors=false
}

private StatementLead ::=
      EXTERN_KEYWORD
    | CLASS_KEYWORD
    | STRUCT_KEYWORD
    | FUNCTION_KEYWORD
    | LET_KEYWORD
    | MUT_KEYWORD
    | WHILE_KEYWORD
    | FOR_KEYWORD
    | LOOP_KEYWORD
    | RETURN_KEYWORD
    | THROW_KEYWORD
    | DEFER_KEYWORD
    | THROWS_KEYWORD
    | SEMICOLON
    | ExpressionLead

private ExpressionLead ::=
      IF_KEYWORD
    | TRUE_KEYWORD
    | FALSE_KEYWORD
    | PAREN_OPEN
    | PAREN_CLOSE
    | CURLY_OPEN
    | CURLY_CLOSE
    | BRACKET_OPEN
    | BRACKET_CLOSE
    | PLUS
    | MINUS
    | EXCLAMATION_POINT
    | STRING_LITERAL
    | CHAR_LITERAL
    | Literal

/*************************************
 *       Extern Declarations         *
 *************************************/

private ExternDeclaration ::= ExternFunctionDeclaration | ExternStructDeclaration {
    extends=TopLevelDefinition
    implements=[
        "org.serenityos.jakt.plugin.psi.declaration.JaktDeclaration"
        "org.serenityos.jakt.plugin.psi.declaration.JaktGeneric"
    ]
}

ExternFunctionDeclaration ::= EXTERN_KEYWORD FunctionHeader {
    extends=TopLevelDefinition
    implements=[
        "org.serenityos.jakt.plugin.psi.declaration.JaktDeclaration"
        "org.serenityos.jakt.plugin.psi.declaration.JaktGeneric"
    ]
    mixin="org.serenityos.jakt.plugin.psi.declaration.JaktExternFunctionDeclarationMixin"
}
private FunctionHeader ::= FUNCTION_KEYWORD IDENTIFIER GenericBounds? ParameterList FunctionReturnType
FunctionReturnType ::= THROWS_KEYWORD? (ARROW Type)?
private ParameterList ::= MemberParameterList | FreeParameterList
private MemberParameterList ::= PAREN_OPEN ThisParameter (COMMA Parameter)* PAREN_CLOSE
private FreeParameterList ::= PAREN_OPEN [Parameter (COMMA Parameter)*] PAREN_CLOSE
ThisParameter ::= MUT_KEYWORD? THIS_KEYWORD
Parameter ::= ANON_KEYWORD? MUT_KEYWORD? IDENTIFIER TypeAnnotation {
    implements="org.serenityos.jakt.plugin.psi.declaration.JaktDeclaration"
    mixin="org.serenityos.jakt.plugin.psi.declaration.JaktParameterMixin"
}

ExternStructDeclaration ::= EXTERN_KEYWORD StructHeader CURLY_OPEN NL ExternStructMembers? NL CURLY_CLOSE {
    extends=TopLevelDefinition
    implements=[
        "org.serenityos.jakt.plugin.psi.declaration.JaktDeclaration"
        "org.serenityos.jakt.plugin.psi.declaration.JaktGeneric"
    ]
    mixin="org.serenityos.jakt.plugin.psi.declaration.JaktExternStructDeclarationMixin"
}
StructHeader ::= (CLASS_KEYWORD | STRUCT_KEYWORD) IDENTIFIER GenericBounds? NL

private ExternStructMembers ::= <<commaOrEolList ExternStructMember>>
ExternStructMember ::= StructVisibility? (StructField | ExternStructMethod)
StructField ::= IDENTIFIER MUT_KEYWORD? TypeAnnotation {
    implements="org.serenityos.jakt.plugin.psi.declaration.JaktDeclaration"
    mixin="org.serenityos.jakt.plugin.psi.declaration.JaktStructFieldMixin"
}
ExternStructMethod ::= FunctionHeader {
    implements=[
        "org.serenityos.jakt.plugin.psi.declaration.JaktDeclaration"
        "org.serenityos.jakt.plugin.psi.declaration.JaktGeneric"
    ]
    mixin="org.serenityos.jakt.plugin.psi.declaration.JaktExternStructMethodMixin"
}

/*************************************
 *      Non-Extern Declarations      *
 *************************************/

FunctionDeclaration ::= FunctionHeader FunctionBody {
    extends=TopLevelDefinition
    implements=[
        "org.serenityos.jakt.plugin.psi.declaration.JaktDeclaration"
        "org.serenityos.jakt.plugin.psi.api.JaktPsiScope"
        "org.serenityos.jakt.plugin.psi.api.JaktModificationBoundary"
        "org.serenityos.jakt.plugin.psi.declaration.JaktGeneric"
    ]
    mixin="org.serenityos.jakt.plugin.psi.declaration.JaktFunctionDeclarationMixin"
}
private FunctionBody ::= Block | FAT_ARROW NL ExpressionWithoutAssignment

NamespaceDeclaration ::= NAMESPACE_KEYWORD IDENTIFIER CURLY_OPEN NL TopLevelDefinitionList? NL CURLY_CLOSE {
    extends=TopLevelDefinition
    implements="org.serenityos.jakt.plugin.psi.declaration.JaktDeclaration"
    mixin="org.serenityos.jakt.plugin.psi.declaration.JaktNamespacedDeclarationMixin"
}
StructDeclaration ::= StructHeader StructBody {
    extends=TopLevelDefinition
    implements=[
        "org.serenityos.jakt.plugin.psi.declaration.JaktGeneric"
        "org.serenityos.jakt.plugin.psi.declaration.JaktDeclaration"
    ]
    mixin="org.serenityos.jakt.plugin.psi.declaration.JaktStructDeclarationMixin"
}
StructBody ::= CURLY_OPEN NL StructMembers? NL CURLY_CLOSE

// Structs
private StructMembers ::= <<commaOrEolList StructMember>>;
StructMember ::= StructVisibility? (StructField | FunctionDeclaration)

StructVisibility ::= PUBLIC_KEYWORD | PRIVATE_KEYWORD
MemberSeparator ::= COMMA? NEWLINE+ | COMMA {name="comma or newline"}

// Enums
EnumDeclaration ::= EnumHead EnumBody {
    extends=TopLevelDefinition
    implements=[
        "org.serenityos.jakt.plugin.psi.declaration.JaktDeclaration"
        "org.serenityos.jakt.plugin.psi.declaration.JaktGeneric"
    ]
    mixin="org.serenityos.jakt.plugin.psi.declaration.JaktEnumDeclarationMixin"
}
private EnumHead ::= BOXED_KEYWORD? ENUM_KEYWORD NL IDENTIFIER NL
private EnumBody ::= UnderlyingTypeEnumBody | NormalEnumBody

UnderlyingTypeEnumBody ::= TypeAnnotation NL CURLY_OPEN NL UnderlyingTypeEnumMembers CURLY_CLOSE

private UnderlyingTypeEnumMembers ::= <<commaOrEolList UnderlyingTypeEnumMember>>
UnderlyingTypeEnumMember ::= IDENTIFIER [EQUALS Expression]

NormalEnumBody ::= GenericBounds? NL CURLY_OPEN NL NormalEnumMembers CURLY_CLOSE

private NormalEnumMembers ::= <<commaOrEolList NormalEnumMember>>
NormalEnumMember ::= IDENTIFIER NormalEnumMemberBody?
private NormalEnumMemberBody ::= PAREN_OPEN NL (TypeEnumMemberBody | StructEnumMemberBody) PAREN_CLOSE
TypeEnumMemberBody ::= <<commaList (Type !COLON)>>
private StructEnumMemberBody ::= <<commaOrEolList StructEnumMemberBodyPart>>
StructEnumMemberBodyPart ::= IDENTIFIER TypeAnnotation

// Import Statement
ImportStatement ::= IMPORT_KEYWORD IDENTIFIER ImportAs? ImportBraceList? {
    extends=TopLevelDefinition
    implements="org.serenityos.jakt.plugin.psi.declaration.JaktDeclaration"
    mixin="org.serenityos.jakt.plugin.psi.declaration.JaktImportStatementMixin"
}
private ImportAs ::= AS IDENTIFIER
private ImportBraceList ::= CURLY_OPEN <<commaOrEolList ImportBraceEntry>> CURLY_CLOSE
ImportBraceEntry ::= IDENTIFIER {
    implements="org.serenityos.jakt.plugin.psi.declaration.JaktDeclaration"
    mixin="org.serenityos.jakt.plugin.psi.declaration.JaktImportBraceEntryMixin"
}

/*************************************
 *            STATEMENTS             *
 *************************************/

private StatementList ::= Statement (StatementSeparator Statement)*
private StatementSeparator ::= (NEWLINE | SEMICOLON)+

Statement ::=
      Expression
    | ReturnStatement
    | ThrowStatement
    | DeferStatement
    | IfStatement
    | WhileStatement
    | LoopStatement
    | ForStatement
    | VariableDeclarationStatement
    | UnsafeStatement
    | InlineCppStatement
    | Block

VariableDeclarationStatement ::= (LET_KEYWORD | MUT_KEYWORD) IDENTIFIER TypeAnnotation? EQUALS ExpressionWithoutAssignment {
    implements="org.serenityos.jakt.plugin.psi.declaration.JaktDeclaration"
    mixin="org.serenityos.jakt.plugin.psi.declaration.JaktVariableDeclarationMixin"
}
IfStatement ::= IF_KEYWORD ExpressionWithoutAssignment Block [ELSE_KEYWORD (IfStatement | Block)]
ReturnStatement ::= RETURN_KEYWORD ExpressionWithoutAssignment?
ThrowStatement ::= THROW_KEYWORD ExpressionWithoutAssignment
DeferStatement ::= DEFER_KEYWORD Statement
WhileStatement ::= WHILE_KEYWORD ExpressionWithoutAssignment Block
LoopStatement ::= LOOP_KEYWORD Block

ForStatement ::= FOR_KEYWORD IDENTIFIER IN_KEYWORD ExpressionWithoutAssignment Block

UnsafeStatement ::= UNSAFE_KEYWORD Block
InlineCppStatement ::= CPP_KEYWORD Block

Block ::= NL CURLY_OPEN NLSEMI <<withOff StatementList? "NO_ASSIGN">> NLSEMI CURLY_CLOSE {
    extends=Statement
    mixin="org.serenityos.jakt.plugin.psi.misc.JaktBlockMixin"
}

/*************************************
 *               TYPES               *
 *************************************/

private BaseType ::=
      DictionaryType
    | ArrayType
    | SetType
    | TupleType
    | PlainType

GenericSpecialization ::= LESS_THAN <<commaOrEolList Type>> GREATER_THAN {pin=1 extends=Type}
ArrayType ::= BRACKET_OPEN Type BRACKET_CLOSE {extends=Type}
DictionaryType ::= BRACKET_OPEN Type COLON Type BRACKET_CLOSE {pin=3 extends=Type}
SetType ::= CURLY_OPEN Type CURLY_CLOSE {pin=1 extends=Type}
TupleType ::= PAREN_OPEN <<commaList Type>> PAREN_CLOSE {pin=1 extends=Type}
PlainType ::= (IDENTIFIER COLON_COLON)* IDENTIFIER GenericSpecialization? {
    extends=Type
    implements="org.serenityos.jakt.plugin.psi.declaration.JaktNameIdentifierOwner"
    mixin="org.serenityos.jakt.plugin.psi.reference.JaktPlainTypeMixin"
}

Type ::=
      RawType
    | WeakType
    | OptionalType
    | BaseType
{
    implements="org.serenityos.jakt.plugin.psi.api.JaktTypeable"
    mixin="org.serenityos.jakt.plugin.psi.misc.JaktTypeMixin"
}

RawType ::= RAW_KEYWORD BaseType {pin=1 extends=Type}
WeakType ::= WEAK_KEYWORD BaseType QUESTION_MARK {pin=1 extends=Type}
OptionalType ::= BaseType QUESTION_MARK {extends=Type}

TypeAnnotation ::= COLON Type {extends=Type}
GenericBounds ::= LESS_THAN <<commaOrEolList GenericBound>> GREATER_THAN
GenericBound ::= IDENTIFIER {
    implements="org.serenityos.jakt.plugin.psi.declaration.JaktDeclaration"
    mixin="org.serenityos.jakt.plugin.psi.declaration.JaktGenericBoundMixin"
}

/*************************************
 *            EXPRESSIONS            *
 *************************************/

// TODO: Pretty much every expression can start with an arbitrary amount of newlines
Expression ::=
      AccessExpression // Must come before CallExpression
    | CallExpression // Must come before RelationalBinaryExpression (because of generics)
    | AssignmentBinaryExpression // Must come before other binary expressions
    | IndexedAccessExpression
    | LogicalOrBinaryExpression
    | LogicalAndBinaryExpression
    | BitwiseOrBinaryExpression
    | BitwiseXorBinaryExpression
    | BitwiseAndBinaryExpression
    | RelationalBinaryExpression
    | ShiftBinaryExpression
    | AddBinaryExpression
    | MultiplyBinaryExpression
    | PrefixUnaryExpression
    | PostfixUnaryExpression
    | ParenExpression
    | FieldAccessExpression
    | RangeExpression
    | ArrayExpression
    | DictionaryExpression
    | SetExpression
    | TupleExpression
    | MatchExpression
    | Literal
    | PlainQualifier

private ExpressionWithoutAssignment ::= <<withOn Expression "NO_ASSIGN">> {name="expression"}

CallExpression ::= Expression GenericSpecialization? Call
private Call ::= PAREN_OPEN NL ArgumentList? PAREN_CLOSE
ArgumentList ::= <<commaOrEolList Argument>>
Argument ::= LabeledArgument | UnlabeledArgument
LabeledArgument ::= IDENTIFIER COLON ExpressionWithoutAssignment {
    implements="org.serenityos.jakt.plugin.psi.declaration.JaktNameIdentifierOwner"
    mixin="org.serenityos.jakt.plugin.psi.reference.JaktLabeledArgumentMixin"
}
UnlabeledArgument ::= ExpressionWithoutAssignment

AccessExpression ::= Expression DOT Access
Access ::= FieldLookup | TupleLookup {
    implements=[
        "org.serenityos.jakt.plugin.psi.api.JaktTypeable"
        "org.serenityos.jakt.plugin.psi.declaration.JaktNameIdentifierOwner"
    ]
    mixin="org.serenityos.jakt.plugin.psi.reference.JaktAccessMixin"
}
private FieldLookup ::= IDENTIFIER
private TupleLookup ::= DECIMAL_LITERAL

IndexedAccessExpression ::= Expression BRACKET_OPEN Expression BRACKET_CLOSE
FieldAccessExpression ::= THIS_KEYWORD? DOT IDENTIFIER {
    implements="org.serenityos.jakt.plugin.psi.declaration.JaktNameIdentifierOwner"
    mixin="org.serenityos.jakt.plugin.psi.reference.JaktFieldAccessExpressionMixin"
}

ParenExpression ::= PAREN_OPEN ExpressionWithoutAssignment PAREN_CLOSE
RangeExpression ::= Expression DOT_DOT Expression

ArrayExpression ::= BRACKET_OPEN NL [SizedArrayBody | ElementsArrayBody] NL BRACKET_CLOSE
SizedArrayBody ::= ExpressionWithoutAssignment SEMICOLON NumericLiteral
ElementsArrayBody ::= <<commaOrEolList ExpressionWithoutAssignment>>

DictionaryExpression ::= BRACKET_OPEN NL [<<commaOrEolList DictionaryElement>> | COLON] NL BRACKET_CLOSE
DictionaryElement ::= Expression COLON NL Expression
SetExpression ::= CURLY_OPEN NL <<commaOrEolList ExpressionWithoutAssignment>>? NL CURLY_CLOSE
TupleExpression ::= PAREN_OPEN NL <<commaOrEolList ExpressionWithoutAssignment>> NL PAREN_CLOSE

MatchExpression ::= MATCH_KEYWORD ExpressionWithoutAssignment NL CURLY_OPEN NL MatchPatterns? NL CURLY_CLOSE
private MatchPatterns ::= <<commaOrEolList MatchPattern>>
MatchPattern ::= PatternHead PatternTrail
PatternTrail ::= FAT_ARROW MatchBody
PatternHead ::= <<pipeList (ELSE_KEYWORD | ExpressionWithoutAssignment)>>
MatchBody ::= Block | Expression

NamespaceQualifier ::= IDENTIFIER COLON_COLON {
    implements=[
        "org.serenityos.jakt.plugin.psi.api.JaktTypeable"
        "org.serenityos.jakt.plugin.psi.declaration.JaktNameIdentifierOwner"
    ]
    mixin="org.serenityos.jakt.plugin.psi.reference.JaktNamespaceQualifierMixin"
}
PlainQualifier ::= NamespaceQualifier* IDENTIFIER {
    extends=Expression
    implements=[
        "org.serenityos.jakt.plugin.psi.api.JaktTypeable"
        "org.serenityos.jakt.plugin.psi.declaration.JaktNameIdentifierOwner"
    ]
    mixin="org.serenityos.jakt.plugin.psi.reference.JaktPlainQualifierMixin"
}

/*************************************
 *        BINARY EXPRESSIONS         *
 *************************************/

fake BinaryExpression ::= Expression+ {
    methods=[left="Expression[0]" right="Expression[1]"]
}

LogicalOrBinaryExpression ::= Expression LogicalOrOp NL Expression
LogicalAndBinaryExpression ::= Expression AND NL Expression
// &ExpressionLead helps disambiguate rules in PatternHead production
BitwiseOrBinaryExpression ::= Expression PIPE NL &ExpressionLead Expression
BitwiseXorBinaryExpression ::= Expression CARET NL Expression
BitwiseAndBinaryExpression ::= Expression AMPERSAND NL Expression
RelationalBinaryExpression ::= Expression RelationalOp NL Expression
ShiftBinaryExpression ::= Expression ShiftOp NL Expression
AddBinaryExpression ::= Expression AddOp NL Expression
MultiplyBinaryExpression ::= Expression MultiplyOp NL Expression
// TODO: Restrict LHS?
// TODO: Invert Expression{WithoutAssignment} => Expression{WithAssignment}, as this can't be a part
//       of the expression tree root
AssignmentBinaryExpression ::= Expression AssignmentOp NL Expression {rightAssociative=true}
fake UnaryExpression ::= PrefixOp? Expression PostfixOp?
PrefixUnaryExpression ::= PrefixOp NL Expression {extends=UnaryExpression}
PostfixUnaryExpression ::= Expression PostfixOp {extends=UnaryExpression}

private AddOp ::= PLUS | MINUS
private MultiplyOp ::= ASTERISK | SLASH | PERCENT
private ShiftOp ::= ARITH_LEFT_SHIFT | LEFT_SHIFT | ARITH_RIGHT_SHIFT | RIGHT_SHIFT
private RelationalOp ::= LESS_THAN_EQUALS | LESS_THAN | GREATER_THAN_EQUALS | GREATER_THAN | DOUBLE_EQUALS | NOT_EQUALS
private LogicalOrOp ::= OR | DOUBLE_QUESTION_MARK
private AssignmentOp ::= [AddOp | MultiplyOp | ShiftOp] EQUALS
private PrefixOp ::=
      PLUS_PLUS
    | MINUS_MINUS
    | MINUS
    | NOT
    | TILDE
    | AMPERSAND RAW_KEYWORD
    | ASTERISK
private PostfixOp ::= PLUS_PLUS | MINUS_MINUS | EXCLAMATION_POINT | AS (QUESTION_MARK | EXCLAMATION_POINT) Type

/*************************************
 *             LITERALS              *
 *************************************/

Literal ::=
      STRING_LITERAL
    | BYTE_CHAR_LITERAL
    | CHAR_LITERAL
    | NumericLiteral
    | BooleanLiteral
    {extends=Expression}

NumericLiteral ::= (BINARY_LITERAL | HEX_LITERAL | DECIMAL_LITERAL) NumericSuffix?
    {extends=Expression}

NumericSuffix ::= 'uz' | 'f32' | 'f64' | 'u8' | 'u16' | 'u32' | 'u64' | 'i8' | 'i16' | 'i32' | 'i64'

BooleanLiteral ::= TRUE_KEYWORD | FALSE_KEYWORD {extends=Expression}

/*************************************
 *             HELPERS               *
 *************************************/

private NL ::= NEWLINE*
private NLSEMI ::= (NEWLINE | SEMICOLON)*
private meta commaList ::= <<p>> (COMMA <<p>>)* COMMA?
private meta pipeList ::= <<p>> (PIPE <<p>>)*
private meta commaOrEolList ::= <<p>> (MemberSeparator <<p>>)* MemberSeparator?
